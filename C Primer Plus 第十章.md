# C Primer Plus 第十章：数组和指针学习笔记  

## 1. 数组基础

### 1.1 数组概述
数组是**一系列相同类型的数据集合**，在内存中占据连续的区域，按顺序存储。

**声明示例：**
```c
int num[10];          // 10个整数的数组
const char letters[5]; // 5个字符的数组（只读）
```

**数组三要素：**
1. **类型** - 数组元素的类型（如`int`、`char`）
2. **大小** - 数组容量（元素个数）
3. **下标** - 访问元素的索引（从0开始）

**重要特性：**
- 数组名是**常量指针**，指向数组首元素
- 最后一个元素的下标 = 数组大小 - 1

### 1.2 偏移量计算
- **地址偏移量** = 首元素地址 + 下标 × 数据类型宽度
- **元素偏移量** = 元素下标差

## 2. 数组初始化

### 2.1 基本初始化方法
```c
// 完全初始化
int arr1[5] = {1, 2, 3, 4, 5};

// 部分初始化（其余自动补0）
int arr2[5] = {1, 2, 3};  // arr2[3]和arr2[4]为0

// 自动推断大小
int arr3[] = {1, 2, 3, 4, 5};  // 编译器自动设为大小5
```

### 2.2 指定初始化器（C99）
```c
// 只初始化特定元素
int arr[5] = {[2] = 30, [4] = 50};  // 其他元素为0
```

## 3. 多维数组

### 3.1 多维数组概念
多维数组本质上是**数组的数组**。

```c
int matrix[3][4];  // 3行4列的二维数组
```
- `matrix` 是`int[3][4]`类型
- `matrix[0]` 是`int[4]`类型（第一行）

### 3.2 多维数组初始化
```c
// 完整初始化
int matrix[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};

// 连续初始化
int matrix2[2][3] = {1, 2, 3, 4, 5, 6};

// 部分初始化
int matrix3[3][4] = {
    {1},        // 第一行：1,0,0,0
    {0, 2},     // 第二行：0,2,0,0
    {[2] = 3}   // 第三行：0,0,3,0
};
```

## 4. 数组与指针的关系

### 4.1 数组名即指针
```c
int arr[5] = {10, 20, 30, 40, 50};

// 以下等价
int *p1 = arr;      // arr即&arr[0]
int *p2 = &arr[0];  // 显式获取首元素地址

arr[2] == *(arr + 2);  // 都为30
```

### 4.2 指针算术与数组访问
```c
int arr[5] = {1, 2, 3, 4, 5};
int *ptr = arr;  // 指向arr[0]

ptr++;      // 现在指向arr[1]
*ptr = 20;  // arr[1]变为20
ptr += 2;   // 现在指向arr[3]
```

## 5. 指针操作详解

### 5.1 基本操作
```c
int a = 10;
int b;

// 1. 赋值
int *p = &a;

// 2. 解引用
b = *p;     // b = 10

// 3. 指针赋值
int *q = p; // q也指向a

// 4. 指针算术
int arr[5] = {0};
int *ptr = arr;
ptr = ptr + 3;  // 指向arr[3]

// 5. 指针相减（同一数组内）
int *p1 = &arr[1];
int *p2 = &arr[4];
int diff = p2 - p1;  // diff = 3
```

### 5.2 注意事项
```c
// 危险：未初始化的指针
int *danger;     // 未初始化
// *danger = 5;  // 未定义行为！

// 正确：先分配内存或指向有效地址
int value = 0;
int *safe = &value;
*safe = 5;       // 安全
```

## 6. 函数中的数组与指针

### 6.1 传递一维数组
两种等价形式：
```c
// 指针形式（推荐）
void func1(int *arr, int size) {
    for(int i = 0; i < size; i++) {
        arr[i] *= 2;
    }
}

// 数组形式（仅函数参数可用）
void func2(int arr[], int size) {
    // 同上
}
```

### 6.2 保护数组数据
使用`const`限定符防止意外修改：
```c
// 1. 只读数组参数
void printArray(const int arr[], int size) {
    // arr[i] = 10;  // 错误！不能修改
}

// 2. 常量指针（指针指向不可变）
int a = 1, b = 2;
int *const p = &a;
// p = &b;  // 错误！不能改变指向
*p = 10;   // 可以！可以修改指向的值

// 3. 指向常量的指针
const int *q = &a;
// *q = 20; // 错误！不能修改值
q = &b;    // 可以！可以改变指向

// 4. 双重保护
const int *const r = &a;
// r = &b;  // 错误！
// *r = 30; // 错误！
```

## 7. 指针与多维数组

### 7.1 指向数组的指针
```c
int matrix[3][4];

// 指向一行的指针
int (*rowPtr)[4] = matrix;  // 指向第一行

// 访问元素
rowPtr[1][2] = 42;          // matrix[1][2] = 42
(*(rowPtr + 1))[2] = 42;    // 等价写法
```

### 7.2 数组指针 vs 指针数组
```c
// 1. 指向数组的指针
int (*ptr1)[4];  // 指向int[4]类型数组的指针

// 2. 指针数组
int *ptr2[4];    // 包含4个int指针的数组
```

### 7.3 传递多维数组给函数
```c
// 二维数组参数（必须指定列数）
void processMatrix(int mat[][4], int rows) {
    for(int i = 0; i < rows; i++) {
        for(int j = 0; j < 4; j++) {
            mat[i][j] = i + j;
        }
    }
}

// 等价指针形式
void processMatrixPtr(int (*mat)[4], int rows) {
    // 同上
}
```

## 8. 变长数组（VLA，C99特性）

```c
#include <stdio.h>

int main() {
    int size;
    printf("输入数组大小：");
    scanf("%d", &size);
    
    int vla[size];  // 运行时确定大小
    
    for(int i = 0; i < size; i++) {
        vla[i] = i * 2;
    }
    
    return 0;
}
```

**注意：** VLA的大小在创建后不可改变，且不能初始化。

## 9. 常见误区与要点

### 9.1 数组名不可赋值
```c
int arr1[5], arr2[5];
// arr1 = arr2;  // 错误！数组名是常量指针
```

### 9.2 数组大小计算
```c
int arr[10];
int size = sizeof(arr) / sizeof(arr[0]);  // 正确：10
```

### 9.3 指针边界检查
```c
int arr[5];
int *p = &arr[4];  // 最后一个元素

p++;  // 指向arr[4]之后（危险但允许比较）
// *p = 10;  // 未定义行为！

// 安全做法：明确边界
if(p < arr + 5) {
    // 安全操作
}
```

## 10. 总结与实践建议

### 10.1 核心关系
1. **数组名**是指向首元素的**常量指针**
2. `arr[i]` 等价于 `*(arr + i)`
3. 数组作为函数参数时，传递的是指针而非整个数组

### 10.2 学习建议
1. **画图理解**：用内存图表示数组和指针关系
2. **循序渐进**：从一维数组开始，逐步过渡到多维
3. **调试观察**：使用调试器查看指针值和内存变化
4. **多写代码**：通过练习加深理解

### 10.3 实用代码片段
```c
// 安全遍历数组
void safeArrayTraversal(int arr[], int size) {
    int *end = arr + size;  // 结束边界
    for(int *p = arr; p < end; p++) {
        printf("%d ", *p);
    }
}

// 多维数组遍历
void traverse2DArray(int mat[][4], int rows) {
    for(int i = 0; i < rows; i++) {
        for(int j = 0; j < 4; j++) {
            printf("%d ", mat[i][j]);
        }
        printf("\n");
    }
}
```

---

**学习心得：**
数组与指针是C语言的核心概念，理解它们的关系至关重要。建议通过以下步骤巩固：
1. 理解数组在内存中的连续存储特性
2. 掌握指针算术与数组访问的等价性
3. 练习使用指针遍历和操作数组
4. 理解`const`在保护数据中的作用
5. 通过调试工具观察内存变化